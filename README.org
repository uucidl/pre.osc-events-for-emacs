A bridge from emacs to OSC, with the intent to augment emacs with
monome.

* OSC bridge process

We will use a separate process to bridge emacs to the OSC protocol.

The process will be initially written in python.

** Monome, serialosc 1.2

With serialosc 1.2, the guys at http://monome.org finally decided to
remove the bonjour requirement from serialosc, and serialosc now has
its own discovery protocol, fortunately based on OSC.

** TODO Setup

First, let's create the requirements files:

#+begin_src text :tangle "bridge/requirements.txt"
pyosc>=0.3.6
sexpdata
#+end_src

#+begin_src text :tangle "bridge/dev_requirements.txt"
nose
mox
#+end_src

And the two scrits init.sh and dev.sh, the first for use and the
second one for development. You are encouraged to call these from
within a virtual environment.

#+begin_src sh :tangle "bridge/init.sh" :exports none
pip install -r requirements.txt
#+end_src

#+begin_src sh :tangle "bridge/dev.sh" :exports none
pip install -r requirements.txt -r dev_requirements.txt
#+end_src

You may also do it from within emacs, assuming you have installed the
python-environment package:

#+begin_src elisp
  (require 'python-environment)

  (defun emacs-osc-install-python-dependencies ()
    (interactive)
    (python-environment-run (list "pip" "install" "-r" "bridge/requirements.txt" "-r" "bridge/dev_requirements.txt")))
#+end_src

Note: in order to execute the python code blocks in babel mode, you
should execute the following:

#+begin_src elisp
  (require 'python-environment)
  (setq-local org-babel-python-command (python-environment-bin "python"))
#+end_src

** Main program

An emacs elisp package will talk to the python bridge:

#+begin_src dot :file arch.png
  digraph g {
	  osc_el -> python_bridge_process [label="s-exp packets"];
	  python_bridge_process -> osc_el [label="s-exp packets"];
	  osc_clients -> python_bridge_process [label="OSC"];
	  python_bridge_process -> osc_servers [label="OSC"];
	  python_bridge_process -> python_bridge_process [label="deferred OSC"];
  }
#+end_src

#+RESULTS:
[[file:arch.png]]

We will treat OSC incoming messages in python and convert them into
s-exp that emacs will then forward to user-handlers.

Each user-sent message is also accepted as a s-expression and
converted to OSC messages in python.

Emacs will in turn send response events or response animations in the
form of OSC bundle to animate on the device. (What if we want to
cancel an animation?)

*** OSC to S-Expr and back

We will define a python module converting osc messages into s-exp,
which will make Emacs' jobs much easier.

#+begin_src python :tangle "bridge/messages.py" :results output
  import mox
  import sexpdata
  import time
  import unittest

  from OSC import (
    OSCBundle,
    OSCMessage,
  )

  OSC_PACKET_SYMBOL = sexpdata.Symbol('osc-packet')

  def osc_message_as_list(osc_message):
      return [osc_message.address] + osc_message.values()

  def list_to_osc_message(lst):
      if not lst:
	  raise Exception('not an osc message')
      message = OSCMessage(lst[0])
      message.extend(lst[1:])

      return message

  def osc_message_as_sexp(osc_message):
      """converts an osc message into a s-expression"""

      return sexpdata.dumps(osc_message_as_list(osc_message))

  def sexp_to_osc_message(sexp):
      data = sexpdata.loads(sexp)
      return list_to_osc_message(data)

  def packet_sexp(from_endpoint, to_endpoint, osc_message):
      return sexpdata.dumps([
	  OSC_PACKET_SYMBOL, from_endpoint, to_endpoint, osc_message_as_list(osc_message),
      ])

  def packet_osc(lst):
      try:
	  if not OSC_PACKET_SYMBOL == lst[0]:
	    raise Exception('unsupported message %r!' % lst)

	  to_address = lst[2].split(':')
	  to_address = to_address[0], int(to_address[1])
	  message = list_to_osc_message(lst[3])
	  timestamp = lst[4] if len(lst) > 4 else None
      except:
	  etype, value, tb = sys.exc_info()
	  raise Exception('unsupported message %s!:%s' % (
	      lst, ''.join(traceback.format_exception(etype, value, tb))
	  ))

      if timestamp is None:
	  timestamp_sec = None
      elif isinstance(timestamp, float):
	  timestamp_sec = timestamp
      elif timestamp[0] == sexpdata.Symbol('relative'):
	  timestamp_sec = time.time() + timestamp[1]

      if timestamp_sec is not None:
	  bundle = OSCBundle(time=timestamp_sec)
	  bundle.extend([ message ])
	  message = bundle

      return message, (to_address)

  class TestMessages(unittest.TestCase):
      def setUp(self):
	  self.mox = mox.Mox()

      def tearDown(self):
	  self.mox.UnsetStubs()

      def assert_roundtrip(self, message):
	  self.assertEquals(message, sexp_to_osc_message(osc_message_as_sexp(message)))

      def test_wrong_sexp(self):
	  self.assertRaises(Exception, sexp_to_osc_message, "nil")
	  self.assertRaises(Exception, sexp_to_osc_message, "()")

      def test_osc_message_as_sexp_trigger(self):
	  message = OSCMessage("/my/address")
	  self.assertEquals('("/my/address")', osc_message_as_sexp(message))
	  self.assert_roundtrip(message)

      def test_osc_message_as_sexp_integer(self):
	  message = OSCMessage("/my/address")
	  message.append(42)
	  message.append(-100042)

	  self.assertEquals('("/my/address" 42 -100042)', osc_message_as_sexp(message))
	  self.assert_roundtrip(message)

      def test_osc_message_as_sexp_string(self):
	  message = OSCMessage("/my/address")
	  message.append('a string')

	  self.assertEquals('("/my/address" "a string")', osc_message_as_sexp(message))
	  self.assert_roundtrip(message)

      def test_osc_message_with_odd_strings(self):
	  message = OSCMessage("/my/address")
	  message.append(u'a \"string\"')

	  self.assertEquals('("/my/address" "a \\"string\\"")', osc_message_as_sexp(message))
	  self.assert_roundtrip(message)

      def test_osc_message_as_sexp_many(self):
	  message = OSCMessage("/my/address")
	  message.append(1)
	  message.append('one')
	  message.append(2)
	  message.append('two')
	  message.append(3)
	  message.append('three')

	  self.assertEquals('("/my/address" 1 "one" 2 "two" 3 "three")', osc_message_as_sexp(message))
	  self.assert_roundtrip(message)

      def test_message_envelope(self):
	  message = OSCMessage("/my/address")
	  message.append(1)
	  message.append('one')

	  received_sexp = packet_sexp('Alice:1', 'Bob:3', message)
	  self.assertEquals('(osc-packet "Alice:1" "Bob:3" ("/my/address" 1 "one"))', received_sexp)

	  parsed_osc_message, to_address = packet_osc(
	      sexpdata.loads(received_sexp)
	  )
	  self.assertEquals(("Bob", 3), to_address)
	  self.assertEquals(message, parsed_osc_message)

      def test_timestamped_message_envelope(self):
	  now_sec = 1377246142.54
	  line = '(osc-packet "from_address" "to_address:1234" ("/my/address" 1 "one") %s)' % now_sec
	  message = OSCMessage("/my/address")
	  message.append(1)
	  message.append('one')

	  bundle = OSCBundle(time=now_sec)
	  bundle.extend([ message ])
	  self.assertEquals((bundle, ('to_address', 1234)), packet_osc(sexpdata.loads(line)))

      def test_relative_timestamps_in_envelopes(self):
	  now_sec = 1377246142.54
	  line = '(osc-packet "from_address" "to_address:1234" ("/my/address" 1 "one") (relative 2.0))'
	  message = OSCMessage("/my/address")
	  message.append(1)
	  message.append('one')

	  bundle = OSCBundle(time=now_sec + 2.0)
	  bundle.extend([ message ])

	  self.mox.StubOutWithMock(time, 'time')
	  time.time().AndReturn(now_sec)
	  self.mox.ReplayAll()

	  self.assertEquals((bundle, ('to_address', 1234)), packet_osc(sexpdata.loads(line)))
	  self.mox.VerifyAll()

  if __name__ == "__main__":
      unittest.main(verbosity=2)
#+end_src

#+RESULTS:

*** Server communication

#+begin_src python :tangle "bridge/main.py" :results output
  import argparse
  import logging
  import mox
  import select
  import sexpdata
  import sys
  import time
  import traceback
  import unittest

  from OSC import (
    OSCBundle,
    OSCClient,
    OSCMessage,
    OSCServer,
    OSCTimeTag,
  )
  from threading import Thread
  from StringIO import StringIO
  from contextlib import closing

  # for patching OSC's OSCTimeTag
  import OSC
  import math
  import struct

  import messages

  logger = logging.getLogger(__name__)

  def accept_message(stream, server, addr, tags, data, client_address):
      logger.debug('received message %r', locals())

      def format_address(address):
	return '%s:%i' % address

      message = OSCMessage(addr)
      message.extend(data)

      stream.write(
	messages.packet_sexp(format_address(client_address), format_address(server.address()), message) +
	'\n'
      )

  def send_message(stream, client):
      msg = stream.read()
      lst = sexpdata.loads(msg)
      if not lst:
	raise Exception('unrecognized message %r!' % msg)

      message, to_address = messages.packet_osc(lst)
      client.sendto(message, to_address)
      logger.debug('sent message %r %r', message, to_address)

  class ServerHandler(object):
    def __init__(self, server, stream):
      self.server = server
      self.stream = stream
      server.addMsgHandler('default', self.sexp_accept_message)

    def sexp_accept_message(self, addr, tags, data, client_address):
      accept_message(self.stream, self.server, addr, tags, data, client_address)


  if __name__ == "__main__":
      parser = argparse.ArgumentParser()
      parser.add_argument('--port', type=int, default=7016)
      args = parser.parse_args()

      logging.basicConfig(level=logging.ERROR)
      #unittest.main()
      import sys

      server = OSCServer(('localhost', args.port))
      ServerHandler(server, sys.stdout)
      thread = Thread(target=lambda: server.serve_forever())
      client = OSCClient(server=server)

      thread.start()

      with closing(server):
	  while True:
	      try:
		  line = sys.stdin.readline()
	      except KeyboardInterrupt:
		  break

	      if not line:
		  break

	      logger.debug("got stdin input: %r", line)
	      send_message(StringIO(line), client)

      thread.join()

  class TestMain(unittest.TestCase):
      def setUp(self):
	  self.mox = mox.Mox()

      def tearDown(self):
	  self.mox.UnsetStubs()

      def test_send_message(self):
	  message = OSCMessage("/my/address")
	  message.append(1)
	  message.append('one')

	  self.mox.StubOutWithMock(messages, 'packet_osc')
	  messages.packet_osc([
	      sexpdata.Symbol('osc-packet'),
	      'from_address',
	      'to_address:1234',
	      ["/my/address", 1, "one"],
	  ]
	  ).AndReturn(
	      (message, ('to_address', 1234))
	  )

	  line = '(osc-packet "from_address" "to_address:1234" ("/my/address" 1 "one"))'

	  client = self.mox.CreateMock(OSCClient)
	  client.sendto(message, ("to_address", 1234))
	  self.mox.ReplayAll()

	  send_message (StringIO(line), client)
	  self.mox.VerifyAll()

#+end_src

#+RESULTS:

Now, we can use this bridge program already to communicate with emacs using its process API:

#+begin_src elisp :tangle osc.el
  (require 'python-environment)

  (defun osc-bridge-message-handler (msg)
    (message (format "%S" msg))
    (if (equal "/monome/enc/delta" (car msg))
	(let ((delta (nth 2 msg)))
	  (if (> 0 delta)
	       (scroll-down delta)
	       (scroll-up (- delta)))))
    (if (equal '("/monome/grid/key" 0 7 1) msg)
	(magit-status default-directory))
    (if (equal '("/monome/grid/key" 0 6 1) msg)
	(other-window 1)))

  (defun osc-bridge-process-input-line (line)
    (let ((data (read line)))
      (nth 3 data)))

  (defun osc-bridge-filter (proc string)
    (when (buffer-live-p (process-buffer proc))
      (let ((message-queue nil))
	(with-current-buffer (process-buffer proc)
	  (let ((moving (= (point) (process-mark proc))))
	    (save-excursion
	      ;; Insert the text, advancing the process marker.
	      (goto-char (process-mark proc))
	      (insert string)
	      (let ((content (buffer-substring (point-min) (point))))
		(let ((rev-lines (nreverse (split-string content "\n" nil))))
		  (let ((last-line (car rev-lines)))
		    (setq message-queue
			  (mapcar #'osc-bridge-process-input-line (cdr rev-lines)))
		    (delete-region (point-min) (point))
		    (insert last-line)))
		(set-marker (process-mark proc) (point))
		(if moving (goto-char (process-mark proc)))))))
      (mapc #'osc-bridge-message-handler message-queue))))

  (defun osc-timetag-in-seconds (time)
    (let ((origin (encode-time 0 0 0 1 1 1900 t)))
      (float-time (time-subtract time origin))))

  (defun osc-send-message (client message &optional timestamp)
    """send an osc message to the client"""
    (let ((process (car client))
	  (endpoint (car (cdr client))))
      (if (and (not (listp message))
	       (not (stringp (first message))))
	  (error (format "malformed message %s" message)))
      (process-send-string
       process
       (format "%S\n" (if timestamp
			  `(osc-packet "127.0.0.1:7016" ,endpoint ,message ,timestamp)
			  `(osc-packet "127.0.0.1:7016" ,endpoint ,message))))))

  ;; start the bridge process
  (progn
   (setq osc-bridge-process
	 (start-process "osc-bridge" "*osc-bridge*"
			(python-environment-bin "python") "bridge/osc.py"))
   (set-process-filter osc-bridge-process #'osc-bridge-filter)

   (setq *grid64-client* `(,osc-bridge-process "127.0.0.1:10775"))
   (setq *arc-client* `(,osc-bridge-process "127.0.0.1:11033")))

  ;; ask the monome for information
  (osc-send-message *arc-client* '("/sys/info" "127.0.0.1" 7016))

  ;; take-focus
  (dolist (client (list *arc-client* *grid64-client*))
    (osc-send-message client '("/sys/host" "127.0.0.1"))
    (osc-send-message client '("/sys/port" 7016)))

  ;; tell an arc to illuminate its ring
  (osc-send-message *arc-client* '("/monome/ring/all" 0 14))
  ;; turn it off
  (osc-send-message *arc-client* '("/monome/ring/all" 0 0))

  (process-send-string
   osc-bridge-process
   (format "%S\n" '(osc-packet "127.0.0.1:7016" "127.0.0.1:12002" ("/serialosc/list" "127.0.0.1" 7016))))

  ;; additional monome
  (process-send-string
   osc-bridge-process
   (format "%S\n" '(osc-packet "127.0.0.1:7016" "127.0.0.1:10775" ("/sys/info" "127.0.0.1" 7016))))

  (process-send-string
   osc-bridge-process
   (format "%S\n" '(osc-packet "127.0.0.1:7016" "127.0.0.1:10775" ("/sys/port" 7016))))

  ;; want tilt?

  (process-send-string
   osc-bridge-process
   (format "%S\n" '(osc-packet "127.0.0.1:7016" "127.0.0.1:10775" ("/monome/tilt/set" 0 0))))
#+end_src

#+RESULTS:

We would like to be able to send sequences in advance from emacs,
especially to do simple feedback animations such as lighting up a
button and turning it off. This requires passing a timetag to the OSC
 message, so that it can be enqueued and played at a later time.

#+begin_src elisp
  ;; start the bridge process
  (progn
   (setq osc-bridge-process
	 (start-process "osc-bridge" "*osc-bridge*"
			(python-environment-bin "python") "bridge/osc.py"))
   (set-process-filter osc-bridge-process #'osc-bridge-filter)

   (setq *grid64-client* `(,osc-bridge-process "127.0.0.1:10775"))
   (setq *arc-client* `(,osc-bridge-process "127.0.0.1:11033")))

  ;; ask the monome for information
  (osc-send-message *arc-client* '("/sys/info" "127.0.0.1" 7016))

  ;; take-focus
  (dolist (client (list *arc-client* *grid64-client*))
    (osc-send-message client '("/sys/host" "127.0.0.1"))
    (osc-send-message client '("/sys/port" 7016)))

  (progn
    ;; tell an arc to illuminate its ring now
    (osc-send-message *arc-client* '("/monome/ring/all" 0 14) (+ (float-time (current-time)) 0.0))
    ;; turn it off three seconds later
    (osc-send-message *arc-client* '("/monome/ring/all" 0 0) (+ (float-time (current-time)) 3.0)))
#+end_src

The above does not work yet because there is a bug in the osc-bridge /
elisp talking to each others when two messages are sent in one shot.

** Using Mario Lang's OSC package

I considered using Mario Lang's OSC package:
- it does not respond well to arc's negative offsets
- I attempted to fix it using bindat, which does support signed integers?

It however gives an idea of the type of OSC api that can function
within Emacs. Macking my package compatible would be a good idea.

#+begin_src elisp
  (setq mm-arc-client (osc-make-client "localhost" 11033))

  (defun mm-take-focus (client server)
    (osc-send-message client "/sys/host" (process-contact server :host))
    (osc-send-message client "/sys/port" (process-contact server :service)))

  (defun mm-ask-info (client)
    (osc-send-message client "/sys/info"))

  (defun mm-make-arc-server (port)
    (osc-make-server "localhost" port #'arc-server-callback))

  (defun arc-server-callback (path &rest args)
    (message "OSC %s: %S" path args))
    (if (equal "/monome/enc/delta" path)
	(let ((delta (nth 1 args)))
	  (if (< 0 delta)
	      (scroll-up (- delta))
	    (scroll-down delta)))))

  (delete-process mm-arc-server)
  (setq mm-arc-server (mm-make-arc-server 7016))
  (set-process-buffer mm-arc-server (get-buffer-create "*OSC* mm-arc-server"))

  (defun mm-switch-frame (event)
    (interactive "e")
    (handle-switch-frame event)
    (message "taking focus from monome %s" event)
    (mm-take-focus mm-arc-client mm-arc-server))

  (define-key (current-global-map) [(switch-frame)] #'mm-switch-frame)

  (mm-take-focus mm-arc-client mm-arc-server)
  (mm-ask-info mm-arc-client)

  (delete-process mm-arc-server)

#+end_src
