A bridge from emacs to OSC, with the intent to augment emacs with
monome.

* OSC bridge process

We will use a separate process to bridge emacs to the OSC protocol.

The process will be initially written in python.

** Setup

First, let's create the requirements files:

#+begin_src text :tangle "bridge/requirements.txt"
pybonjour
pyosc
#+end_src

#+begin_src text :tangle "bridge/dev_requirements.txt"
nose
#+end_src

And the two scrits init.sh and dev.sh, the first for use and the
second one for development. You are encouraged to call these from
within a virtual environment.

#+begin_src sh :tangle "bridge/init.sh" :exports none
pip install -r requirements.txt
#+end_src

#+begin_src sh :tangle "bridge/dev.sh" :exports none
pip install -r requirements.txt -r dev_requirements.txt
#+end_src

You may also do it from within emacs, assuming you have installed the
python-environment package:

#+begin_src elisp
  (require 'python-environment)

  (defun emacs-osc-install-python-dependencies ()
    (interactive)
    (python-environment-run (list "pip" "install" "-r" "bridge/requirements.txt" "-r" "bridge/dev_requirements.txt")))
#+end_src

*** Main program

Note: in order to execute the following in babel mode, you may execute the following:

#+begin_src elisp
 (setq-local org-babel-python-command (python-environment-bin "python"))
#+end_src

#+RESULTS:
: /Users/nicolas/.emacs.d/python-environment/bin/python

Prototyping the main loop:

#+begin_src python :tangle "bridge/main.py"
  import time
  import pybonjour
  import OSC
  import sys
  import select

  def monome_service_cb(sdRef, flags, interfaceIndex, errorCode, serviceName, regtype, replyDomain):
       print 'hello %(regtype)s %(serviceName)s %(replyDomain)s' % locals()

  print "browsing bonjour:"
  with pybonjour.DNSServiceBrowse(regtype='_monome-osc._udp', callBack=monome_service_cb) as bonjour:
       try:
	    while True:
		 ready = select.select([bonjour], [], [])
		 if bonjour in ready[0]:
		      pybonjour.DNSServiceProcessResult(bonjour)
       except KeyboardInterrupt:
	    pass

  assert False, "not implemented yet %r" % (bonjour)
#+end_src

We will treat OSC incoming messages and transform them into emacs
events, which can be bound to. (What do we do with values like those
emitted by the arc.. Mouse like events?)

"mouse-movement are represented by lists that look like (mouse-movement position)"
see eventp function

Emacs' command loop does not seem extensible..

read-event, see Reading Input info section.

Emacs will in turn send response events or response animations in the
form of OSC bundle to animate on the device. (What if we want to
cancel an animation?)

** Using Mario Lang's OSC package

The below is an experiment. The OSC package from Mario Lang does not
respond well to arc's negative offsets, even with my own hacks.

#+begin_src elisp
  (setq mm-arc-client (osc-make-client "localhost" 11033))

  (defun mm-take-focus (client server)
    (osc-send-message client "/sys/host" (process-contact server :host))
    (osc-send-message client "/sys/port" (process-contact server :service)))

  (defun mm-ask-info (client)
    (osc-send-message client "/sys/info"))

  (defun mm-make-arc-server (port)
    (osc-make-server "localhost" port #'arc-server-callback))

  (defun arc-server-callback (path &rest args)
    (message "OSC %s: %S" path args))
    (if (equal "/monome/enc/delta" path)
	(let ((delta (nth 1 args)))
	  (if (< 0 delta)
	      (scroll-up (- delta))
	    (scroll-down delta)))))

  (delete-process mm-arc-server)
  (setq mm-arc-server (mm-make-arc-server 7016))
  (set-process-buffer mm-arc-server (get-buffer-create "*OSC* mm-arc-server"))

  (defun mm-switch-frame (event)
    (interactive "e")
    (handle-switch-frame event)
    (message "taking focus from monome %s" event)
    (mm-take-focus mm-arc-client mm-arc-server))

  (define-key (current-global-map) [(switch-frame)] #'mm-switch-frame)

  (mm-take-focus mm-arc-client mm-arc-server)
  (mm-ask-info mm-arc-client)

  (delete-process mm-arc-server)


#+end_src
