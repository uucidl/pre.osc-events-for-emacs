A bridge from emacs to OSC, with the intent to augment emacs with
monome.

* OSC bridge process

We will use a separate process to bridge emacs to the OSC protocol.

The process will be initially written in python.

** Setup

First, let's create the requirements files:

#+begin_src text :tangle "bridge/requirements.txt"
pybonjour
pyosc
sexpdata
#+end_src

#+begin_src text :tangle "bridge/dev_requirements.txt"
nose
#+end_src

And the two scrits init.sh and dev.sh, the first for use and the
second one for development. You are encouraged to call these from
within a virtual environment.

#+begin_src sh :tangle "bridge/init.sh" :exports none
pip install -r requirements.txt
#+end_src

#+begin_src sh :tangle "bridge/dev.sh" :exports none
pip install -r requirements.txt -r dev_requirements.txt
#+end_src

You may also do it from within emacs, assuming you have installed the
python-environment package:

#+begin_src elisp
  (require 'python-environment)

  (defun emacs-osc-install-python-dependencies ()
    (interactive)
    (python-environment-run (list "pip" "install" "-r" "bridge/requirements.txt" "-r" "bridge/dev_requirements.txt")))
#+end_src

#+RESULTS:
: emacs-osc-install-python-dependencies

** Main program

Note: in order to execute the following in babel mode, you may execute the following:

#+begin_src elisp
 (setq-local org-babel-python-command (python-environment-bin "python"))
#+end_src

#+RESULTS:
: /Users/nicolas/.emacs.d/python-environment/bin/python

Prototyping the main loop:

#+begin_src python :tangle "bridge/main.py"
  import time
  import pybonjour
  import OSC
  import sys
  import select

  def monome_service_cb(sdRef, flags, interfaceIndex, errorCode, serviceName, regtype, replyDomain):
       print 'hello %(regtype)s %(serviceName)s %(replyDomain)s' % locals()

  print "browsing bonjour:"
  with pybonjour.DNSServiceBrowse(regtype='_monome-osc._udp', callBack=monome_service_cb) as bonjour:
       try:
	    while True:
		 ready = select.select([bonjour], [], [])
		 if bonjour in ready[0]:
		      pybonjour.DNSServiceProcessResult(bonjour)
       except KeyboardInterrupt:
	    pass

  assert False, "not implemented yet %r" % (bonjour)
#+end_src

#+RESULTS:

An emacs elisp package will talk to the python bridge:

#+begin_src dot :file arch.png
  digraph g {
	  monome_el -> osc_el;
	  osc_el -> monome_el;
	  monome_el -> python_bridge_process;
	  python_bridge_process -> monome_el;
	  osc_el -> python_bridge_process;
	  python_bridge_process -> osc_el;
	  osc_clients -> python_bridge_process;
	  python_bridge_process -> osc_servers;
  }
#+end_src

#+RESULTS:
[[file:arch.png]]


We will treat OSC incoming messages in python and convert them into
s-exp that emacs will then forward to user-handlers.

We will treat user-sent responses/messages and convert them to OSC
messages in python.

Emacs will in turn send response events or response animations in the
form of OSC bundle to animate on the device. (What if we want to
cancel an animation?)

The bonjour part is not absolutely critical, and can be split.

We will define a python module converting osc messages into s-exp,
which will make Emacs' jobs much easier.

#+begin_src python :tangle "bridge/osc.py" :results output
  # -*- coding: utf-8 -*-
  import unittest
  import sexpdata

  from OSC import OSCMessage

  def osc_message_as_sexp(osc_message):
      """converts an osc message into a s-expression"""

      return sexpdata.dumps([osc_message.address] + osc_message.values())

  def sexp_to_osc_message(sexp):
      data = sexpdata.loads(sexp)
      if not data:
	  raise Exception('not an osc message')
      message = OSCMessage(data[0])
      message.extend(data[1:])

      return message

  class TestOSCBridge(unittest.TestCase):
      def assert_roundtrip(self, message):
	  self.assertEquals(message, sexp_to_osc_message(osc_message_as_sexp(message)))

      def test_osc_message_as_sexp_trigger(self):
	  message = OSCMessage("/my/address")
	  self.assertEquals('("/my/address")', osc_message_as_sexp(message))
	  self.assert_roundtrip(message)

      def test_osc_message_as_sexp_integer(self):
	  message = OSCMessage("/my/address")
	  message.append(42)
	  message.append(-100042)

	  self.assertEquals('("/my/address" 42 -100042)', osc_message_as_sexp(message))
	  self.assert_roundtrip(message)

      def test_osc_message_as_sexp_string(self):
	  message = OSCMessage("/my/address")
	  message.append('a string')

	  self.assertEquals('("/my/address" "a string")', osc_message_as_sexp(message))
	  self.assert_roundtrip(message)

      def test_osc_message_with_odd_strings(self):
	  message = OSCMessage("/my/address")
	  message.append(u'a \"string\"')

	  self.assertEquals('("/my/address" "a \\"string\\"")', osc_message_as_sexp(message))
	  self.assert_roundtrip(message)

      def test_osc_message_as_sexp_many(self):
	  message = OSCMessage("/my/address")
	  message.append(1)
	  message.append('one')
	  message.append(2)
	  message.append('two')
	  message.append(3)
	  message.append('three')

	  self.assertEquals('("/my/address" 1 "one" 2 "two" 3 "three")', osc_message_as_sexp(message))
	  self.assert_roundtrip(message)


  if __name__ == "__main__":
      unittest.main()

#+end_src

#+RESULTS:

** Using Mario Lang's OSC package

The below is an experiment. The OSC package from Mario Lang does not
respond well to arc's negative offsets, even with my own hacks.

It however gives an idea of the type of OSC api that can function
within Emacs. Macking my package compatible would be a good idea.

#+begin_src elisp
  (setq mm-arc-client (osc-make-client "localhost" 11033))

  (defun mm-take-focus (client server)
    (osc-send-message client "/sys/host" (process-contact server :host))
    (osc-send-message client "/sys/port" (process-contact server :service)))

  (defun mm-ask-info (client)
    (osc-send-message client "/sys/info"))

  (defun mm-make-arc-server (port)
    (osc-make-server "localhost" port #'arc-server-callback))

  (defun arc-server-callback (path &rest args)
    (message "OSC %s: %S" path args))
    (if (equal "/monome/enc/delta" path)
	(let ((delta (nth 1 args)))
	  (if (< 0 delta)
	      (scroll-up (- delta))
	    (scroll-down delta)))))

  (delete-process mm-arc-server)
  (setq mm-arc-server (mm-make-arc-server 7016))
  (set-process-buffer mm-arc-server (get-buffer-create "*OSC* mm-arc-server"))

  (defun mm-switch-frame (event)
    (interactive "e")
    (handle-switch-frame event)
    (message "taking focus from monome %s" event)
    (mm-take-focus mm-arc-client mm-arc-server))

  (define-key (current-global-map) [(switch-frame)] #'mm-switch-frame)

  (mm-take-focus mm-arc-client mm-arc-server)
  (mm-ask-info mm-arc-client)

  (delete-process mm-arc-server)


#+end_src
