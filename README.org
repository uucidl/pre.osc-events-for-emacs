A bridge from emacs to OSC, with the intent to augment emacs with
monome.

* OSC bridge process

We will use a separate process to bridge emacs to the OSC protocol.

The process will be initially written in python.

** TODO Remove bonjour from requirements

Finally the guys at http://monome.org decided to remove the bonjour
requirement from serialosc, and serialosc now has its own discovery
protocol, fortunately based on OSC.

With this I should be able to remove all mentions below about bonjour.

** TODO Setup

First, let's create the requirements files:

#+begin_src text :tangle "bridge/requirements.txt"
pybonjour
pyosc
sexpdata
#+end_src

#+begin_src text :tangle "bridge/dev_requirements.txt"
nose
mox
#+end_src

And the two scrits init.sh and dev.sh, the first for use and the
second one for development. You are encouraged to call these from
within a virtual environment.

#+begin_src sh :tangle "bridge/init.sh" :exports none
pip install -r requirements.txt
#+end_src

#+begin_src sh :tangle "bridge/dev.sh" :exports none
pip install -r requirements.txt -r dev_requirements.txt
#+end_src

You may also do it from within emacs, assuming you have installed the
python-environment package:

#+begin_src elisp
  (require 'python-environment)

  (defun emacs-osc-install-python-dependencies ()
    (interactive)
    (python-environment-run (list "pip" "install" "-r" "bridge/requirements.txt" "-r" "bridge/dev_requirements.txt")))
#+end_src

#+RESULTS:
: emacs-osc-install-python-dependencies

** Main program

Note: in order to execute the following in babel mode, you may execute the following:

#+begin_src elisp
  (require 'python-environment)
  (setq-local org-babel-python-command (python-environment-bin "python"))
#+end_src

#+RESULTS:
: /Users/nicolas/.emacs.d/python-environment/bin/python

Prototyping the main loop:

#+begin_src python :tangle "bridge/main.py"
  import time
  import pybonjour
  import OSC
  import sys
  import select

  def monome_service_cb(sdRef, flags, interfaceIndex, errorCode, serviceName, regtype, replyDomain):
       print 'hello %(regtype)s %(serviceName)s %(replyDomain)s' % locals()

  print "browsing bonjour:"
  with pybonjour.DNSServiceBrowse(regtype='_monome-osc._udp', callBack=monome_service_cb) as bonjour:
       try:
	    while True:
		 ready = select.select([bonjour], [], [])
		 if bonjour in ready[0]:
		      pybonjour.DNSServiceProcessResult(bonjour)
       except KeyboardInterrupt:
	    pass

  assert False, "not implemented yet %r" % (bonjour)
#+end_src

#+RESULTS:

An emacs elisp package will talk to the python bridge:

#+begin_src dot :file arch.png
  digraph g {
	  monome_el -> osc_el;
	  osc_el -> monome_el;
	  monome_el -> python_bridge_process;
	  python_bridge_process -> monome_el;
	  osc_el -> python_bridge_process;
	  python_bridge_process -> osc_el;
	  osc_clients -> python_bridge_process;
	  python_bridge_process -> osc_servers;
  }
#+end_src

#+RESULTS:
[[file:arch.png]]


We will treat OSC incoming messages in python and convert them into
s-exp that emacs will then forward to user-handlers.

We will treat user-sent responses/messages and convert them to OSC
messages in python.

Emacs will in turn send response events or response animations in the
form of OSC bundle to animate on the device. (What if we want to
cancel an animation?)

The bonjour part is not absolutely critical, and can be split.

We will define a python module converting osc messages into s-exp,
which will make Emacs' jobs much easier.

#+begin_src python :tangle "bridge/osc.py" :results output
  # -*- coding: utf-8 -*-
  import logging
  import mox
  import select
  import sexpdata
  import unittest

  from OSC import (
    OSCClient,
    OSCMessage,
    OSCServer,
  )
  from StringIO import StringIO

  OSC_PACKET_SYMBOL = sexpdata.Symbol('osc-packet')

  logger = logging.getLogger(__name__)

  def osc_message_as_list(osc_message):
      return [osc_message.address] + osc_message.values()

  def list_to_osc_message(lst):
      if not lst:
	  raise Exception('not an osc message')
      message = OSCMessage(lst[0])
      message.extend(lst[1:])

      return message

  def osc_message_as_sexp(osc_message):
      """converts an osc message into a s-expression"""

      return sexpdata.dumps(osc_message_as_list(osc_message))

  def sexp_to_osc_message(sexp):
      data = sexpdata.loads(sexp)
      return list_to_osc_message(data)

  def packet_sexp(from_endpoint, to_endpoint, osc_message):
      return sexpdata.dumps([
	  OSC_PACKET_SYMBOL, from_endpoint, to_endpoint, osc_message_as_list(osc_message),
      ])

  def accept_message(stream, server, addr, tags, data, client_address):
      logger.debug('received message %r', locals())

      def format_address(address):
	return '%s:%i' % address

      message = OSCMessage(addr)
      message.extend(data)

      stream.write(
	packet_sexp(format_address(client_address), format_address(server.address()), message) +
	'\n'
      )

  def send_message(stream, client):
      msg = stream.read()
      lst = sexpdata.loads(msg)
      if not lst:
	raise Exception('unrecognized message %r!' % msg)

      if not OSC_PACKET_SYMBOL == lst[0]:
	raise Exception('unsupported message %r!' % msg)

      to_address = lst[2].split(':')
      to_address = to_address[0], int(to_address[1])
      message = list_to_osc_message(lst[3])
      client.sendto(message, to_address)
      logger.debug('sent message %r %r', message, to_address)

  class ServerHandler(object):
    def __init__(self, server, stream):
      self.server = server
      self.stream = stream
      server.addMsgHandler('default', self.sexp_accept_message)

    def sexp_accept_message(self, addr, tags, data, client_address):
      accept_message(self.stream, self.server, addr, tags, data, client_address)

  class TestOSCBridge(unittest.TestCase):
      def setUp(self):
	  self.mox = mox.Mox()

      def tearDown(self):
	  self.mox.UnsetStubs()

      def assert_roundtrip(self, message):
	  self.assertEquals(message, sexp_to_osc_message(osc_message_as_sexp(message)))

      def test_wrong_sexp(self):
	  self.assertRaises(Exception, sexp_to_osc_message, "nil")
	  self.assertRaises(Exception, sexp_to_osc_message, "()")

      def test_osc_message_as_sexp_trigger(self):
	  message = OSCMessage("/my/address")
	  self.assertEquals('("/my/address")', osc_message_as_sexp(message))
	  self.assert_roundtrip(message)

      def test_osc_message_as_sexp_integer(self):
	  message = OSCMessage("/my/address")
	  message.append(42)
	  message.append(-100042)

	  self.assertEquals('("/my/address" 42 -100042)', osc_message_as_sexp(message))
	  self.assert_roundtrip(message)

      def test_osc_message_as_sexp_string(self):
	  message = OSCMessage("/my/address")
	  message.append('a string')

	  self.assertEquals('("/my/address" "a string")', osc_message_as_sexp(message))
	  self.assert_roundtrip(message)

      def test_osc_message_with_odd_strings(self):
	  message = OSCMessage("/my/address")
	  message.append(u'a \"string\"')

	  self.assertEquals('("/my/address" "a \\"string\\"")', osc_message_as_sexp(message))
	  self.assert_roundtrip(message)

      def test_osc_message_as_sexp_many(self):
	  message = OSCMessage("/my/address")
	  message.append(1)
	  message.append('one')
	  message.append(2)
	  message.append('two')
	  message.append(3)
	  message.append('three')

	  self.assertEquals('("/my/address" 1 "one" 2 "two" 3 "three")', osc_message_as_sexp(message))
	  self.assert_roundtrip(message)

      def test_received_message_envelope(self):
	  message = OSCMessage("/my/address")
	  message.append(1)
	  message.append('one')

	  received_sexp = packet_sexp('Alice', 'Bob', message)
	  self.assertEquals('(osc-packet "Alice" "Bob" ("/my/address" 1 "one"))', received_sexp)

      def test_send_message(self):
	  line = '(osc-packet "from_address" "to_address:1234" ("/my/address" 1 "one"))'
	  message = OSCMessage("/my/address")
	  message.append(1)
	  message.append('one')

	  client = self.mox.CreateMock(OSCClient)
	  client.sendto(message, ("to_address", 1234))
	  self.mox.ReplayAll()

	  send_message (StringIO(line), client)
	  self.mox.VerifyAll()

  if __name__ == "__main__":
      logging.basicConfig(level=logging.INFO)
      #unittest.main()
      import sys

      server = OSCServer(('localhost', 7016))
      ServerHandler(server, sys.stdout)
      client = OSCClient()

      try:
	while True:
	  ready = select.select([server.fileno(), sys.stdin], [], [])
	  if server.fileno() in ready[0]:
	    server.handle_request()
	  if sys.stdin in ready[0]:
	    line = sys.stdin.readline()
	    logger.debug("got stdin input: %r", line)
	    send_message(StringIO(line), client)
      except KeyboardInterrupt:
	pass

#+end_src

#+RESULTS:

Now, we can use this bridge program already to communicate with emacs using its process API:

#+begin_src elisp
  (require 'python-environment)

  (defun osc-bridge-message-handler (msg)
    (message (format "%S" msg))
    (if (equal "/monome/enc/delta" (car msg))
	(let ((delta (nth 2 msg)))
	  (if (> 0 delta)
	       (scroll-down delta)
	       (scroll-up (- delta)))))
    (if (equal '("/monome/grid/key" 0 7 1) msg)
	(magit-status default-directory))
    (if (equal '("/monome/grid/key" 0 6 1) msg)
	(other-window 1)))

  (defun osc-bridge-process-input-line (line)
    (let ((data (read line)))
      (nth 3 data)))

  (defun osc-bridge-filter (proc string)
    (when (buffer-live-p (process-buffer proc))
      (let ((message-queue nil))
	(with-current-buffer (process-buffer proc)
	  (let ((moving (= (point) (process-mark proc))))
	    (save-excursion
	      ;; Insert the text, advancing the process marker.
	      (goto-char (process-mark proc))
	      (insert string)
	      (let ((content (buffer-substring (point-min) (point))))
		(let ((rev-lines (nreverse (split-string content "\n" nil))))
		  (let ((last-line (car rev-lines)))
		    (setq message-queue
			  (mapcar #'osc-bridge-process-input-line (cdr rev-lines)))
		    (delete-region (point-min) (point))
		    (insert last-line)))
		(set-marker (process-mark proc) (point))
		(if moving (goto-char (process-mark proc)))))))
      (mapc #'osc-bridge-message-handler message-queue))))

  ;; start the bridge process
  (setq osc-bridge-process
	(start-process "osc-bridge" "*osc-bridge*"
		       (python-environment-bin "python") "bridge/osc.py"))
  (set-process-filter osc-bridge-process #'osc-bridge-filter)

  (defun osc-send-message (client message)
    """send an osc message to the client"""
    (let ((process (car client))
	  (endpoint (car (cdr client))))
      (if (and (not (listp message))
	       (not (stringp (first message))))
	  (error (format "malformed message %s" message)))
      (process-send-string
       process
       (format "%S\n" `(osc-packet "127.0.0.1:7016" ,endpoint ,message)))))

  (setq *grid64-client* `(,osc-bridge-process "127.0.0.1:10775"))
  (setq *arc-client* `(,osc-bridge-process "127.0.0.1:11033"))

  ;; ask the monome for information
  (osc-send-message *arc-client* '("/sys/info" "127.0.0.1" 7016))

  ;; take-focus
  (dolist (client (list *arc-client* *grid64-client*))
    (osc-send-message client '("/sys/host" "127.0.0.1"))
    (osc-send-message client '("/sys/port" 7016)))

  ;; tell an arc to illuminate its ring
  (osc-send-message *arc-client* '("/monome/ring/all" 0 14))
  ;; turn it off
  (osc-send-message *arc-client* '("/monome/ring/all" 0 0))

  (process-send-string
   osc-bridge-process
   (format "%S\n" '(osc-packet "127.0.0.1:7016" "127.0.0.1:12002" ("/serialosc/list" "127.0.0.1" 7016))))

  ;; additional monome
  (process-send-string
   osc-bridge-process
   (format "%S\n" '(osc-packet "127.0.0.1:7016" "127.0.0.1:10775" ("/sys/info" "127.0.0.1" 7016))))

  (process-send-string
   osc-bridge-process
   (format "%S\n" '(osc-packet "127.0.0.1:7016" "127.0.0.1:10775" ("/sys/port" 7016))))

  ;; want tilt?

  (process-send-string
   osc-bridge-process
   (format "%S\n" '(osc-packet "127.0.0.1:7016" "127.0.0.1:10775" ("/monome/tilt/set" 0 0))))
#+end_src

#+RESULTS:

** Using Mario Lang's OSC package

The below is an experiment. The OSC package from Mario Lang does not
respond well to arc's negative offsets, even with my own hacks.

It however gives an idea of the type of OSC api that can function
within Emacs. Macking my package compatible would be a good idea.

#+begin_src elisp
  (setq mm-arc-client (osc-make-client "localhost" 11033))

  (defun mm-take-focus (client server)
    (osc-send-message client "/sys/host" (process-contact server :host))
    (osc-send-message client "/sys/port" (process-contact server :service)))

  (defun mm-ask-info (client)
    (osc-send-message client "/sys/info"))

  (defun mm-make-arc-server (port)
    (osc-make-server "localhost" port #'arc-server-callback))

  (defun arc-server-callback (path &rest args)
    (message "OSC %s: %S" path args))
    (if (equal "/monome/enc/delta" path)
	(let ((delta (nth 1 args)))
	  (if (< 0 delta)
	      (scroll-up (- delta))
	    (scroll-down delta)))))

  (delete-process mm-arc-server)
  (setq mm-arc-server (mm-make-arc-server 7016))
  (set-process-buffer mm-arc-server (get-buffer-create "*OSC* mm-arc-server"))

  (defun mm-switch-frame (event)
    (interactive "e")
    (handle-switch-frame event)
    (message "taking focus from monome %s" event)
    (mm-take-focus mm-arc-client mm-arc-server))

  (define-key (current-global-map) [(switch-frame)] #'mm-switch-frame)

  (mm-take-focus mm-arc-client mm-arc-server)
  (mm-ask-info mm-arc-client)

  (delete-process mm-arc-server)


#+end_src
